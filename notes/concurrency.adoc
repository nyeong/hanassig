= 동시성
An Nyeong <me@annyeong.me>
:description: 어플리케이션에서 동시성을 다루는 방법
:keywords: os, concurrency

> 동시성은 여러 일을 한꺼번에 다루는 것이다. 병렬성은 여러 일을 한꺼번에 해내는 것이다.
> -- 롭 파이크, https://go.dev/blog/waza-talk

== 동시성과 병렬성

일부에서는 동시성을 병행성이라 부르기도 한다. 병렬성과의 명확한 구분을 위해 동시성이라 부르자.

**동시성**(concurrency)은 논리적 개념으로, 문제를 어떻게 다루냐에 대햔 개념이다.
여러 문제를 한 번에 해결한다면 이는 동시적이다. 가정용 컴퓨터에 CPU는 하나이지만 시분할 시스템 덕분에 CPU가 이 작업 저 작업 시간을 쪼개어 번갈아가며 수행하므로
동시적이다. 동시성의 핵심은 논리적 흐름 제어이다.

**병렬성**(parallelism)은 물리적 개념으로, 문제를 어떻게 해결하냐에 대한 개념이다.
CPU 내에 여러 코어가 있다면 하나의 일을 여럿으로 쪼개어 여러 코어에게 위임하여 해결할 수 있을 것이다. 실제로 여러 프로세스가 동시에 일을 하고 있으므로 물리적이다.

동시적인데 병렬적이지 않을 수 있다. 맥도날드에 직원(말 그대로 worker)이 한 명이라고 생각해보자. 직원이 해결해야 하는 문제는 여럿이다. 주문도 받아야하고,
포션을 튀기거나 패티도 구워야하고, 속재료도 채워 넣고, 매장 내 청결도 해결해야한다. 직원은 자신의 시간을 쪼개어 이를 해결해나가겠지만, 절대 동시에
두 가지 일을 물리적으로 해낼 순 없다.

병렬적인데 동시적이지 않을 수 있을까? 보기에 따라서는 한 가지의 문제를 여러 물리 단위로 해결하고 있는 상황을 그렇게 볼 수 있을 것이다. 직원이 두 명인데
패티만 굽고 있다면, 패티 굽기라는 하나의 상황에 대해 병렬적으로 해결하고 있다고 볼 수 있을 것이다.

=== 병렬성

병렬성의 핵심은 컴퓨팅 분리이다. 한 곳에서 해결하는 문제를 여러곳에서 해결하도록 분리해야한다. 현대 컴퓨터는 저수준부터 고수준에 이르기까지 다양한 방법으로
문제를 병렬적으로 해결하고 있다.

버스의 크기가 커지면 한 번에 더 많은 작업을 할 수 있다. 64비트에서 병렬적으로 한 번에 처리할 수 있는 일을 8비트 컴퓨터로는 6번에 나누어 처리해야한다.

CPU 파이프라이닝을 통해 CPU를 병렬적으로 쓸 수 있다. 명령어를 인출하고, 해석하고, 실행하고, 저장하는 것을 반복한다면 이는 단순한 순차적 작업이다.
명령어를 해석하는 동안 다음 명령어를 미리 인출할 수 있으면 더 CPU를 효율적으로 쓸 수 있을 것이다.

오늘날 CPU는 멀티코어이다. 여러 코어가 서로 다른 작업을 병렬적으로 처리할 수 있다.

하나의 컴퓨터 시스템이 하던 일을 여러 시스템이 나누어 한 후 합치면 일을 병렬적으로 해결할 수 있다.

=== 동시성이 필요한 이유

- 실세계가 동시적이기 때문에
  - 프로그램은 좋든 싫든, 의도했든 안했든 실세계와 상호작용한다. 그 실세계가 동시적이므로 동시성이 필요하다.
  - 동시성이 없다면 파일을 다운 받으며 마우스를 움직일 수 없다.
- 더 나은 성능을 위해
  - 한 번에 하나의 요청만 처리할 수 있는 서버는 성능이 좋지 못하다.
  - 현대 프로그램에서는 I/O에서 버리는 시간이 많다.
  - 결과를 기다리는 동안 다른 일을 할 수 있다면 좋을 것이다.
  - 성능 향상을 보장하지는 않는다. 동시성을 실현하기 위한 비용이 더 클 수도 있다.

== 동시성을 다루는 방법

가장 기본적인 동시적 프로그램은 운영체제이다. 운영체제는 시스템의 한정된 자원을 여러 작업들에게 이상적으로 분배해주어야 한다.
분배하는 방법에는 크게 두 가지 방법이 있다. 제어권을 각 프로그램이 갖는 방법과 제어권을 운영체제가 독점하는 방법이다.

각 프로그램에게 제어권이 있으면 프로그램이 자신의 작업을 안전하게 종료하고 제어권을 넘겨줄 수 있다.
반면 각 프로그램이 제어권을 독점해버릴 문제도 존재한다. 이를 협력적 멀티태스킹 혹은 비선점형 멀티태스킹이라고 부른다.

제어권을 운영체제가 독점하고 여러 프로그램에게 짧게 나눠주고 돌려받을 수도 있다. 이를 선점형 멀티태스킹이라고 부른다.
오늘날 대부분의 운영체제가 채택하고 있는 방법이다.
footnote:[이름만 보면 프로그램이 제어권을 선점할 것 같은데, 실제론 반대의 의미이다. 헷갈려서 그런지 일본에서는 preemptive multitasking을 그대로
음차해서 부르는 것 같다. "비협력적"이라는 용어도 쓰는 듯?]

선점형 멀티태스킹 모델에서는 프로그램에게 제어권이 없다. 따라서 공유 메모리에 서로 다른 제어 주체가 의도치 않게 접근하여
예기치 못한 오류가 발생할 수 있다. 이를 경쟁 위험이라고 하며 경쟁 위험을 막기 위한 여러 동시성 모델이 있다.

"코딩을 지탱하는 기술"에서는 경쟁 위험을 막기 위한 방법을 크게 세 가지로 구분한다:

공유하지 않기:::

- 운영체제는 프로세스를 동시적으로 실행하지만 각 프로세스는 서로 메모리를 공유하지 않는다.
- 액터는 프로세스와 비슷하다. 액터들은 서로 메모리를 공유하는 대신 메시지를 주고 받는다.
- CSP도 비슷하다. 메모리를 공유하는 대신 채널을 만들어 통신한다.

변경하지 않기:::

- 여러 함수형 언어에서 할당한 값은 기본적으로 불변이다. 값이 바뀌지 않으므로 공유해도 문제가 없다. (하스켈, 클로저, 엘릭서 등)
- 모든 값을 불변으로 다루는 것이 어렵다면 적어도 불변을 장려한다. (러스트, 스칼라, 스위프트 등)

끼어들지 않기:::

공유하고 변경하더라도 타이밍만 잘 맞다면 문제가 없다. 중간에 끼어들지만 않으면 된다.

- 선점형 멀티태스킹을 활용한다. 파이버, 그린스레드, 코루틴 등이 이에 해당한다.
- 작업 중인 메모리에 다른 작업이 끼어들지 못하도록 한다. 락, 뮤텍스, 세마포어, STM 등이 이에 해당한다.

## 프로세스

현대 운영체제에서 프로그램은 프로세스라는 단위로 실행되며, 운영체제에서 여러가지 스케줄링 전략으로 동시적으로 다뤄준다.

그러나 각 프로세스는 서로 메모리를 공유하지 않는다. 정보 교환을 위해서는 별도의 방법이 필요하며 이를 IPC; inter-process communication이라고 한다.

예를 들어 텍스트 편집기인 helix editor를 실행하면, 이 편집기는 실행한 파일의 언어에 맞는 LSP 서버 프로세스를 실행한다. 운영체제는 이 두 프로세스를 알아서
잘 동시적으로 운용하고, 두 프로세스는 서로 표준입출력을 이용하여 정보를 교환한다.

## 쓰레드

### GIL

- Node js server scaling with multiple processes
  - Sync problem -> Redis

## 액터

프로그램을 액터(_actor_)와 액터 사이의 의사소통으로 본다. 각 액터는 동시에 돌아가며 정보 공유는 메시지 전달을 통해 이루어진다.

- BEAM VM -> 4KB

## 채널

CSP는 순차 프로세스 통신(_communicating sequential process_)의 약어이다. 스레드 사이에서 메시지를 통해 값을 공유한다는 점에서 액터와 유사하다. 액터가 메시지를 주고 받는 주체인 액터에 초점을 맞춘 것에 비해, CSP는 메시지를 주고 받는 채널에 초점을 맞추었다.

고 언어에서 언어 수준에서 지원하며 많은 주목을 받았다.

> Do not communicate by sharing memory; instead, share memory by communicating.
>
> 공유 메모리로 communication하지말자. communication하여 메모리를 공유하자.
>
> -- [Effective Go](https://go.dev/doc/effective_go#sharing)

## 함수형 프로그래밍

함수형 프로그래밍(_FP; functional programming_)에서는 불변 변수를 최대한 활용하고, 부수 작용을 통제하는 프로그래밍 방법론이다.

## 그린 스레드

스레드와 비슷하게 쓸 수 있다. 프로그래밍 모델을 바꿀 필요가 없다. 스레드보다 오버헤드가 적어 많은 양의 그린 스레드를 만들 수 있다.

## 스레드

- 스레드는 이미 널리 쓰이는 개념이며 운영체제에서 지원한다.
- 기존의 동기 코드나 라이브러리를 쉽게 이용할 수 있다.
- 하지만 각 스레드를 서로 동기화 하는 것은 어렵고, 스레드를 생성하고 스위칭하는 비용도 비싸다.

스레드 풀을 만들어 비용을 줄일 수도 있다.

- 커널 스레드: 운영체제 커널이 스케줄링한다.
- 유저 스레드: 프로세스가 직접 스레드를 스케줄링한다. 커널이 볼 때에는 일반적인 프로세스로 보인다.

## 락

교착 상태(_deadlock_)의 위험이 있다.

### 교착 상태

1.  상호 배제(_mutual exclusion_)
2.  점유 상태로 대기 (Hold and wait)
3.  선점 불가 (No preemption)
4.  순환성 대기 (Circular wait)

## STM

Software transaction memory
clojure.

## 비동기 프로그래밍

C#, rust, JS 등.

비동기 프로그래밍은 오늘날 점점 더 많은 언어에서 지원하는 동시성 프로그래밍 모델이다. `async/await` 문법을 이용하여 코드가 동기적으로 보이도록 한다.

적은 CPU, 메모리 오버헤드를 소모한다. 특히 서버나 DB 같은 많은 양의 IO 작업에 유리하다. 적은 수의 스레드를 런타임으로 활용하여 많고 비용이 적은 비동기 작업을 처리할 수 있다.

## 이벤트 기반 설계

이벤트 기반 설계(_event driven architecture_) 혹은 이벤트 루프는 성능이 우수하며 스레드 수가 적어도 데이터 흐름과 오류 전파를 따라가기 힘들다.

자바스크립트에서 주로 사용한다.

## observerable

RxSwift, RxJs 등

## 용어

### 공유 자원

시스템 안에서 여러 스레드나 프로세스가 함께 접근할 수 있는 자원을 공유 자원(_shared resource_)이라고 한다.

### 임계 영역

공유 자원에 접근하는 코드들을 임계 영역(_critical section_)이라고 한다.

[상호 배제](#상호-배제) 등의 기법으로 임계 영역에 하나의 쓰레드만이 진입하도록 보장해야한다.

임계 영역이 제대로 설정되지 않으면 아래와 같은 문제가 발생할 수 있다:

- 입출금 문제

### 경쟁 상태

여러 스레드가 동시에 임계 영역에 접근하여 발생하는 문제를 경쟁 상태(_race condition_) 혹은 경쟁 위험(_race hazard_)라고 한다.

### 상호 배제

[임계 영역](#임계-영역)에 한 개의 프로세스만 진입할 수 있도록, 즉 원자적으로 실행할 수 있도록 하는 기법을 상호 배제(_mutual exclution_)라고 한다.

임계 영역을 잠궈서 원자적으로 다룰 수 있다. 이를 락(_lock_)이라고 부르며 락을 구현한 자료구조나 스마트 포인터를 흔히 mutex라고 부른다.

```rust
// 상호 배제가 가능한 변수를 선언한다.
let m = Mutex::new(5);
{
    // 변수에 접근하기 전에 먼저 임계 영역을 잠근다.
	let mut num = m.lock().unwrap();

	// 변수에 마음대로 접근할 수 있다.
	*num = 6;

    // 러스트에서는 블록이 끝나면 자동으로 잠금을 푼다.
}
```

== 참고

- 니시오 히로카즈, 코딩을 지탱하는 기술 : 원리로 깨우치는 프로그래밍 기법, 2013.
- 폴 부처, 7가지 동시성 모델, 2016.
- [Clojure Concurrency Tutorial for Beginners with Code Examples](https://ericnormand.me/guide/clojure-concurrency#threadsjvm)
- [동시성 프로그래밍 하기 좋은 Clojure](https://www.slideshare.net/eunminn/clojure-68804824)
- [[Track 1-2] 유인동 - ES6+ 비동기 프로그래밍과 실전 에러 핸들링](https://www.youtube.com/watch?v=o9JnT4sneAQ)
- [[Track 2-2] 나석주 - 비동기를 우아하게 처리하기 위한 Observable](https://www.youtube.com/watch?v=oHF8PEkteq0)
- [Why Async? - Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html)
- [데브시스터즈 서버 직군은 왜 코딩 면접을 볼까?](https://tech.devsisters.com/posts/server-position-coding-test/)
- [주니어 웹 개발자가 알아야 할 '비동기 통신'](https://yozm.wishket.com/magazine/detail/1982/)
- [동시성, 병렬, 비동기, 논블럭킹과 컨셉들](https://black7375.tistory.com/90)
- 남정현, https://blog.cro.sh/slides/async-rust-programming-20220801-redistributable.pdf[Rust 비동기 프로그래밍]
. https://x.com/simnalamburt/status/1309545412160675840?s=20[스레드 세이프티 고려 안한 인터프리터 언어에 스레드 넣는 타 선례들]
