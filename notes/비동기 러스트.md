---
title: 비동기 러스트
---
프
## 채널

러스트에서는 `std::sync::mpsc` 모듈로 채널이 내장되어있다. mpsc란 Multi-producer, single-consumer queue의 약어이다. 말 그대로 여러 곳에서 보낼 수 있으나 단 한 곳에서만 받을 수 있다. 

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    // mpsc::channel() 함수로 채널을 만들 수 있다.
    // sender로 보내고 receiver로 받는다.
    // 각각은 Sender<T>, Receiver<T> 타입이다.
    // 송신자는 필요하면 `clone`할 수 있다.
    let (sender, receiver) = mpsc::channel();

    thread::spawn(move || {
        sender.send(10).unwrap();
    });

    let recv = receiver.recv().unwrap();

    println!("receive is {}", recv);
}
```

송신자가 모두 Drop되거나 수신자가 Drop되면 채널이 닫혔다(*closed*)고 본다. 채널이 닫히면 `send`와 `recv`는 에러를 반환하기 때문에 이들의 반환형은 `Result`이다.

`recv`는 채널에서 값을 꺼내는데, 없으면 블록하고 값을 기다린다. `try_recv` 메소드는 블록하지 않으며 버퍼가 비었을 때에도 에러를 반환한다.

`channel()`로 만든 송신자는 `Sender<T>`로, `send` 함수가 블록되지 않고 돌아간다. `sync_channel(usize)`로 버퍼가 있는 동기 채널을 만들 수 있는데, 이때의 송신자인 `SyncSender<T>`는 `send` 할 때 버퍼가 가득 차 있으면 보낼 수 있을 때까지 블록된다.

### 소유권

`send` 함수의 타입은 `send(&self, t: T)`로 소유권을 가져간다.

```rust
thread::spawn(move || {
    let s = String::new();
    sender.send(s);
    // `send`가 가져각기 때문에 여기서부터는 `s`를 쓸 수 없다.
});
```



## 참고

- [[동시성을 다루는 방법]]
- [[식사하는 철학자 문제]]
- [Rust without the async (hard) part | Lunatic](https://lunatic.solutions/blog/rust-without-the-async-hard-part/)