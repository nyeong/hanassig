= neovim

* <<asciidoc-blog-pipeline#,Asciidoc 블로깅 파이프라인>>
* <<neovim-with-zellij#,neovim ♥️ zellij>>

== 키맵

대부분의 에디터는 키맵을 고민할 필요가 없다. 이미 다양한 기능을 편리하게 쓸 수 있는 키맵이 잘 짜여있다.
VS Code, Zed 등의 에디터는 최신 운영체제와 대부분 호환되므로 배우는 비용 또한 낮다.
다른 곳에서 쓰던 Ctrl+Z, Ctrl+C, Ctrl+S, Ctrl+F를 아무 문제 없이 그대로 쓸 수 있다.
조금 이질적인 Helix, Kakoune도 기본적으로 제공하는 기능이 많고 이를 효율적으로 사용할 수 있도록 키맵을 고민하여
만들었다.

(neo)vim은 상황이 좀 다르다. vim의 키맵은 레거시 그 자체이다. vim은 tty가 정말 teletypewriter인 시절부터 시작한다.
1969년, 켄 톰슨이 UNIX를 만들 때 ed라는 이름의 편집기를 함께 만든다. 이 시기에 사용한 컴퓨터는 PDP-7인데,
출력은 프린터, 프로그램은 천공 테이프로 입력하였다. 지금과 같은 것은 키보드 뿐이다.

필연적으로 ed는 명령어에 기반한 행 단위 편집기여야만했다. 주 출력장치가 프린터이기 때문이다. 매번 전체 내용을
출력할 수는 없었다. 어떤 줄을 볼지, 바꿀지, 지울지 명령어를 입력해야했다. 정말로 입력을 하기 위해서는 "입력모드"로
바꾸어야만 했다. ed는 1978년에 ex라는 프로그램으로 개량되었다. 이 때는 결과물을 보여줄 수 있는 "화면",
비디오 터미널이 개발된 후이다. 이를 이용하여 행단위가 아닌 전체 파일을 볼 수 있는 비주얼 모드가 도입되었다.
이를 vi라고 불렀다. 반대로 vi에서 ex의 명령어를 실행하려면 `:`을 입력하면 된다. 이를 ex모드라고 부른다. <<wvcf>>

vim은 전신타자기 시대의 유산이자 동시에 망령이다. GUI 앱인 일반적엔 에디터와는 다를 수 밖에 없는 출발선에서 왔다.
그래서 ctrl+c가 아니라 ``"+y``로 클립보드로 복사하고, ctrl+f가 아니라 ``:s/pattern/replace/g``로 찾아 바꾼다.

이렇게 보면 오늘날에는 영 쓸 이유가 없는 물건이지만, 살아남은 데에는 다 이유가 있다.
터미널에서 돌아가기 때문에 셸 접속만 하면 쓸 수 있다.
단축키 체계는 규칙이 명확한 언어와 같아서 간단하게 확장할 수 있다.
유닉스 명령과 결합이 쉽기 때문에 필요한 기능을 간단하게 확장할 수 있다.
그리고 무엇보다 내가 원하는 시행착오를 이미 겪은 사람들이 있다.

따라서 아래를 고민하여 나만의 키맵을 완성하자:

. 본래의 기능 중 어떤 기능을 어떤 키맵에 다시 매핑할 지를 고민해야한다.
. 어떤 플러그인의 어떤 기능을 어떤 키맵에 매핑할 지를 고민해야한다.

.원칙
. 루아로 작성하자. vim만을 위해 VimScript를 배우고 싶지는 않다.
. 루아, bash, 유닉스 명령어 선에서 해결하자. 정말 필요하면 다른 언어를 붙이자.
. 최대한 tree-sitter, LSP를 활용하자.
. 별도로 정리 문서를 작성하는 것을 피하자. 의사결정이나 원칙만을 정리하자.
.. 설정 파일이 문서가 되도록 하자.

== 플러그인

* lsp
** [ ] nvim-lspconfig
** [ ] mason-lspconfig
** [ ] mason
* autocomplete
** [ ] hrsh7th/cmp-nvim-lsp
** [ ] hrsh7th/cmp-buffer
** [ ] hrsh7th/cmp-path
** [ ] hrsh7th/cmp-cmdline
** [ ] hrsh7th/cmp-calc
** [ ] hrsh7th/cmp-nvim-lsp-signature-help
** [ ] hrsh7th/cmp-nvim-lsp-document-symbol
* etc
** [ ] glepnir/lspsaga.nvim
** [ ] j-hui/fidget.nvim
** [ ] folke/trouble.nvim

== 치트시트

vim 자체 혹은 일반적인 플러그인의 명령어만 모음

=== 텍스트 오브젝트

vim에서 대상을 지정하기 위한 명령어

----
[i|a][w|s|p|괄호쌍|t]
----

* `i`: inner. 내부 선택.
* `a`: arround. 외부까지 선택.
* `w`: word. 단어.
* `s`: sentence. 문장.
* `p`: paragraph. 문단.
* `t`: 태그.

예시:

* `daw`: 단어 지우기
* `cip`: 문장 지우고 수정하기
* `yi(`: 괄호 안의 내용 복사하기

=== 괄호 다루기

with github:[tpope/vim-surround].

----
[y|d|c]s[모션|텍스트 오브젝트]감쌀 단어
----

* `ys`: 감싸기
* `ds`: 지우기
* `cs`: 바꾸기

이때 감쌀 괄호가 여는 괄호(`(, [, {`)면 안에 공백을 함께 추가한다.
html 태그는 추가할 때에는 `<tag_name>` 혹은 ``t``라고 쓰면 된다.

* `ds(`: 괄호 지우기
* `cs([`: 괄호 바꾸기
* `ysiw(`: 괄호로 감싸기 (`ys`)
* `yss(`: 괄호로 줄 전체 감싸기
* `ysi((`: 괄호를 괄호로 또 감싸기
* (비주얼 모드에서) `S`: 영역 감싸기


=== 대소문자 변경

* `g~<motion>`: 대소문자 맞바꿈
* `gU<motion>`: 대문자로 바꿈
* `gu<motion>`: 소문자로 바꿈

=== 디렉토리 열기

== helix에서 vim으로

helix에서 사용하던 주요 키맵을 vim에선 어떻게 쓰는지

=== 이동

h, j, k, l, w, e

줄 처음, 시작, 끝으로 이동

* helix: gh, gs, gl
* vim: 0, ^, $

=== 단어 삭제

cw

=== 찾아 바꾸기

* helix: `%s찾을단어<ret>c바꿀단어<esc>`
* vim: `%s/찾을단어/바꿀단어/g<ret>`

helix에서는 ``%s찾을단어<ret>c바꿀단어<esc>``이다. ``%``로 문서 전체를 선택하고 ``s``로 선택
영역에서 원하는 내용만 찾아 선택한다. 그 후 ``c``를 눌러 선택된 영역을 원하는 단어로 바꾼다.
큰 과정을 잘게 쪼갤 수 있고, 각각의 동작도 유용해서 외우기 쉬운데, vim은 와닿지 않는 ed 명령어
`:%s/찾을단어/바꿀단어/g<ret>`를 써야 해서 아쉽다.

=== 파일탐색

* helix: bf

=== 버퍼

버퍼 닫기

* helix: bc
* vim: bw

[bibliography]
== 참고

. https://kodingwarrior.github.io/wiki/appendix/excelcon-2nd/[제 2회 EXCELCON - Neovim으로 생산성 퀀텀점프하기]
. https://vimdoc.sourceforge.net/htmldoc/motion.html#left-right-motions
. [[[mulcur]]] Christoph Hermann, https://medium.com/@schtoeffel/you-don-t-need-more-than-one-cursor-in-vim-2c44117d51db[You don’t need more than one cursor in vim]
. ap, https://github.com/ap/vim-buftabline#why-this-and-not-vim-tabs[Why this and not Vim tabs?], vim-buftabline
. [[[wvcf]]] Two-Bit History, https://blog.koriel.kr/where-vim-came-from/[Vim은 어디서 왔나]. Jinsoo Heo 역.
. Helix https://github.com/helix-editor/helix/wiki/Keymap-brainstorm[Keymap brainstorm].
. 이종립, https://youtu.be/oQh-fJZccjo?t=1185[Clojure에 빠진 사람 Vim푸라기라도 잡는다].
