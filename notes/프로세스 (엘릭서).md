---
title: "프로세스 (엘릭서)"
tags: [elixir]
---

액터 모델의 액터에 해당하는 단위를 엘릭서와 얼랭에서는 프로세스로 부른다.

## 생성

```elixir
@spec spawn(module, atom, list) :: pid
```

`module`과 `atom`은 실행할 함수를, `list`는 넘길 인자 리스트를 의미한다.
반환값인 `pid`는 프로세스 식별자이다.

```elixir
iex> spawn(SpawnBasic, :greet, [])
```

## 메시지 주고 받기

`send/2` 함수와 `receive` 매크로로 프로세스끼리 메시지를 주고 받을 수 있다.

### 보낼 때

`send/2` 함수를 이용하여 보낸다. 첫 인수는 `pid`, 메시지를 받을 프로세스이다.
두번째 인수는 `term()`으로 아무 값이나 보내도 된다.

```elixir
iex> pid = spawn(Module, :function, [])
iex> send pid, {:ok, message}
```

### 받을 때

`receive` 매크로로 해당 프로세스에 도착한 메시지를 받아본다.
패턴매칭을 이용하여 메시지가 매칭되는 절을 실행한다.

```elixir
receive do
  {:ok, message} ->
    IO.puts message
end
```

`receive` 매크로는 기본적으로 메시지를 받을 때까지 블록된다. 이를 원치 않으면
`after` 절을 써서 타임아웃되도록 한다.

```elixir
receive do
  {:ok, message} ->
    IO.puts "do something with #{message}"
  after 500 ->
    IO.puts "timeout"
end
```

또한 기본적으로 한 번에 하나의 메시지만 처리하므로, 여러 메시지를 처리하기
원한다면 재귀를 써야 한다.

```elixir
def loop do
  receive do
    {:ok, message} ->
      IO.puts "do something with #{message}"
  end
  loop
end
```

### 주고 받기

메시지는 비동기적으로 전달된다. 보내는 쪽에서는 보내기만 할 뿐 별도로 응답을 받지 않는데, 필요한 경우 받는 쪽에서 도로 보내도록 하여서 응답을 받을 수 있다.

`make_ref/0`는 고유한 레퍼런스를 하나 만든다. 처리 순서가 바뀌더라도 `ref` 값과 비교하여 받기 때문에 안전하다.

```elixir
def print(content) do
  ref = make_ref()
  send(printer, {:print, content, self(), ref})
  receive do
    {:ok, ^ref, content} -> content
    {:error, reason} -> # handle error
  end
end

# printer에서...
def loop do
  receive do
    {:print, content, sender, ref} ->
      # print it
      send(sender, {:ok, ref, content})
  end
end
```

프로세스는 엘릭서에서 상태를 다루는 방법 중 하나이다. 프로세스가 루프의 인자로
상태를 들고 있으면, 다른 프로세스에서 활용할 수 있다.

```elixir
## a loop for stack process
def loop([h | l] = state) do
  receive do
    {:push, elem} ->
      loop([elem | state])

    {:pop, caller} ->
      send caller, h
      loop(l)
  end
end

iex> send stack, {:push, 1}
iex> send stack, {:pop, self()}
```

## 상태 다루기

프로세서는 살아(*alive*)있을 수도, 에러로 인하여 죽어있을 수도 있다. 프로세스의 상태는 `Process.info/1`로 알 수 있다. 가능한 상태는 아래와 같다:

- `:exiting`
- `:garbage_collecting`
- `:waiting`
- `:running`
- `:runnable`
- `:suspended`

```elixir
iex> boom = fn ->
...>   :timer.sleep 500
...>   exit :boom
...> end
iex> pid = spawn(boom)
iex> Process.info(pid, status) # 프로세스가 살아있어서 상태를 반환한다.
{:status, :runnable}
iex> Process.info(pid, status) # 프로세스가 죽어서 `nil`이 반환된다.
nil
```

`Process.link/1` 함수로 현재 프로세스와 다른 프로세스를 링크할 수 있다. 프로세스를 링크하면 
`spawn_link` 함수를 쓰면 생성과 링크를 한 번에 할 수 있다.

```
iex> spawn boom      # 아무 일도 일어나지 않는다
iex> spawn_link boom # spawn한 프로세스가 `exit` 되므로 현재 프로세스도 종료된다.
** (EXIT from #PID<0.105.0>) shell process exited with reason: :boom
```

`Process.monitor/1` 함수나 `spawn_monitor` 함수를 사용하면 단방향으로 프로세스를 연결할 수 있다.