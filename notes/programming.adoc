= 프로그래밍
An Nyeong <me@annyeong.me>
:description: 특정 언어/기술과 무관한 일반적인 개념들

== 알아야 하는 것들

새 언어를 접했을 때

. 기본 도구와 생태계
  * 버전 관리자 (asdf, rustup 등)
  * 의존성 (VM, 라이브러리)
  * 개발환경 (IDE, LSP, REPL)

. 타이핑 모델
  * 동적인가, 정적인가
  * 점진적 타이핑이 가능한가
  * 명목적(_nominal_)인가 구조적(_structural_)인가
  * ADT는 있는가

. 프로그래밍 패러다임
  * 이 언어가 주로 해결하려고 하는 문제는 무엇인가
  * 함수형, 객체지향, 스택 기반, 배열 기반 등등등

. 기본 자료구조
  * 컨테이너 (list, hashmap)
  * 합타입, 곱타입

. 제어구조
  * 논리제어
  * 반복제어
  * 패턴매칭

. 문서화

. 다형성을 달성하는 방법

. 동시성을 달성하는 방법

. <<error-handling,예외를 처리하는 방법>>

. 커뮤니티
  * 스타일 가이드
  * 서드파티 라이브러리

[error-handling]
== 예외를 처리하는 방법

.언제 분기를 처리하는가
. LBYL; Look Before You Leap
. EAFP; Easier to Ask for Forgiveness than Permission

.어떻게 에러임을 알려주는가
. 평범한 값으로 반환하기
. 특수한 값으로 반환하기
. 오류를 던지기

=== 평범한 값으로 반환하기

값에 에러 정보가 포함된 경우

```c
#include <stdio.h>

int main() {
  FILE * file = fopen("somefile", "r");
  if (file == NULL) {
    // handle error
  }
  // do something with file
}
```

=== 특수한 값으로 반환하기

에러가 날 수 있는 함수는, 목표한 값에 에러 정보를 추가로 붙여서 준다.

Go는 튜플로 준다: `(file * File, err error)`

```go
f, err := os.Open("filename.ext")
if err != nil {
    // handle error
}
// do something with the open *File f
```

Elixir는 유니온으로 준다: `{:ok, result} | {:error, reason}`

```elixir
case File.open("foo.tar.gz", [:read, :compressed]) do
  {:ok, file} ->
    // do something with file
  {:error, reason} ->
    // handle error
end
```

Rust는 명목적인 새 타입으로 준다: `Result<T, E>`

```rust
use std::fs::File;
use std::io::Read;

fn main() {
    let file = File::open("foo.txt");
    match file {
        Ok(file) => file,
	Err(error) => // handle error
    }
}
```

[eager_lazy]
== Eager vs lazy

Eager::

열렬한, 열심인. greedy라고도 한다.

Lazy::

게으른.

1. 계산할 때
2. 다른 서비스로 요청을 보낼 때

== 동시성

<<concurrency#,동시성>> 참고
