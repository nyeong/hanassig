---
title: 급하게 파이썬 배우기
tags: [python]
---

## REPL

```python
# type 함수로 값의 타입을 알 수 있음
type({}) # => <class 'dict'>
```

## 산술연산

```python
# 나누기 연산 결과는 float임
35 / 5 # => 7.0

# 몫을 구하는 연산자가 따로 있음
35 // 5 # => 7

# 모듈러 연산자도 있음
35 % 3 # => 2

# 제곱 연산자가 있음
2 ** 3 # => 8

# 형변환이 필요한 경우 `int`와 `float` 함수를 이용
```

## 논리 연산

```python
# 참 거짓은 대문자로 시작
True
False

# `not`, `and`, `or`
not True
True and True
False or True

# 산술 연산에서는 1과 0으로 취급함
True + True # => 2
1 == True # => True

# `bool` 함수를 생성자로 쓸 수 있음
# 0, None, 빈 컨테이너는 False로 취급함
# None은 null, nil과 같음.
bool(0) # => False
bool([]) # => False
bool({}) # => False

# 비교 연산은 `==`, `!=`. 나머지는 아는 대로.
# `==`는 값의 비교. `is`는 존재의 비교
[1, 2, 3] == [1, 2, 3] # => True
[1, 2, 3] is [1, 2, 3] # => False
```

## 문자열

```python
# ""랑 ''랑 차이가 없음
# 문자열 합치기는 `+`
"안녕" + '세상아' # => '안녕세상아'

# 배열 인덱싱 가능
"안녕 세상아"[2] # => ' '

# 길이 구하기는 `len()`

# 문자열 보간은 f"`{variable}`"
# 혹은 `"{순서}".format()` 함수를 이용
# 혹은 `% (value)` 이용
age = "17"
f"저는 영원한 {age}세입니다"

# 포맷팅
print('{0:5s}')
print('{0:>10s}')
print('{0:<10s}')
print('{cel:.2f}')
```

## 제어구문

```python
# 삼항연산자는 TrueCaluse if Condition else FalseCaluse
"good" if True else "bad"

# 들여쓰기가 중요함
if True:
	"good"
else:
	"bad"

# for-in 문법
for animal in ["dog", "cat"]:
	print(f"{animal}")

# for로 dict 순회
for key in a:
	pass
for val in a.values():
	pass
for key, val in a.items():
	pass

# for comprehension
[x for x in [1, 2, 3] if x % 2 == 0] # => [2]

# while문
while True:
	pass
```

## 자료구조

```python
# 리스트. 가변임
[1, 2, 3]

# concat은 extend()
l = [1, 2, 3]
m = [4, 5, 6]
l.extend(m)
l # => [1, 2, 3, 4, 5, 6]

# 원소 추가하기
l.append(20)

# 원소 빼기
l.pop()

# 튜플. 불변임
(1, 2, 3)

# 딕셔너리. (3.6부터는 ordered)
# 키는 불변, 값은 가변.
a = {'a': 1}

# 업데이트
a['a'] = new_value

# 키가 있는지는 key in dict
if 'a' in d:
	do_something(d['a'])

# collections 모듈에 있는 것
# - deque
# - Counter
# - OrderedDict
# - namedtuple
```

## 익명함수

람다라고 있긴 한데 권장하지 아니함.

### 복사

```python
# 그냥 대입하면 복사되지 않는다.
a = {}
b = a
a is b # => True

# `copy`로 얕은 복사
# 얕은 복사라서 
a = {1: [1]}
b = a.copy()
a is b # => False
a[0] is b[0] # => True

# `copy.deepcopy()`로 깊은 복사
import copy
a = {1: [1]}
b = copy.deepcopy(a)
a is b # => False
a[0] is b[0] # => False
```

## 클래스

```python
# class로 클래스 만들 수 있음
# 상속하려면 인자로 상속 객체를 넘김.
class Node(object):
	# 생성자는 `__init__(self)`로 정의함
	# 호출은 `Node()`
	# self를 명시적으로 넘기는 게 특이함.
	def __init__(self):
		self.어쩌구=0

	# 그 외의 특수한 예약 함수. magic matehod라고 함.
	# __str__, __add__, __eq__, __main__
	# __str__은 str로 포맷할 내용을 정의.
	# __add__는 `+`에 대응하는 동작.
	def __str__(self):
		return "str"
```

## 이터 툴

```python
# itertools에서 불러와야함
import itertools

# groupby
itertools.groupby(data, key=keyfunc)

# reduce는 functools에 따로 있음
from functools import reduce
```

## 모듈

- `import X`: 파일을 모두 메모리에 불러오기
- `import X as X'`: alias
- `from X import Y`: 특정 함수, 클래스만 호출하기
- `from X import *`: 모든 함수, 클래스를 호출하기

```python
# some_file.py
def some_function():
	return 'something'
```

```python
# 다른 파일에서 불러오기
# 기본적으로 같은 디렉토리에 있어야
import some_file

# 모듈 속 모듈 불러오기
import some_module.sub_module

# 상대경로 사용하기
import ..some_module

# 모듈.함수
some_file.some_function()
```


디렉토리로 분리하려면 `__init__.py`를 엔트리 포인트로 쓰면 됨.
없어도 패키지로 인식은 함.

### init

```python
# __init__.py

# 서브 모듈에 대한 정의
__all__ = ["module1", "module2"]

# 불러오기
from . import module1
from . import module2
```

### main

패키지에 대한 엔트리 포인트

```python
# __main__.py

if __name__ == "__main__":
	do_something()
```

### built-in module

- `random`
- `time`
- `urllib`
- `os`
- `logging`

```python
import logging

logger = logging.getLogger('main')

logging.basicConfig(level=logging.DEBUG)
logger.setLevel(logging.INFO)

# 따로 파일로 로그 뺴기
stream_handler = logging.FileHandler()
logger.addHandler(stream_handler)

# 아래로 갈수록 중요함
logger.debug('')
logger.info('')
logger.warning('')
logger.error('')
logger.critical('')
```

## 예외처리

- try-except 문법
- 대표적인 예외
	- IndexError, NameError, ZeroDivisionError, ValueError, FileNotFoundError

```python
try:
	# 예외가 발생할 가능성이 있는 작업
	10 / 0
except ZeroDivisionError:
	# 예외를 어떻게 처리할지
	print('divided by zero occured.')
except Exception as e:
	# 모든 에러를 변수 `e`로 받아서 처리
	print(e)
else:
	# 에러가 발생하지 않았을 경우 실행할 블록
finally:
	# 에러가 발생하든 말든 실행해야하는 블록.
	# 사용한 자원 처리 등

# raise로 에러 발생시키기
def some_function():
	raise ValueError("message")
```

## 파일처리

- `open(filename, mode)`
- `file.read()` -- 다 가져옴
- `file.write(data)`
- `file.close()`

```python
# with 구문을 쓰면 close를 까먹지 않을 수 있음.
with open("filename", "r") as f:
	do_something_with(f)
```

디렉토리는 `os`, `os.path`, `shutil` 모듈이 유용함.

- `os.mkdir(dirname)`
- `os.path.exists(dirname)`
- `os.path.isfile(filename)`
- `shutil.copy(src, dest)`

파이썬 객체를 영속화 할 때에는 `pickle`

```python
import pickle

# 파일에 객체를 영속화하여 쓰기
test = [1, 2, 3, 4, 5]
f = open("file", "wb")
pickle.dump(test, f)
f.close()

# 파일을 불러오기
test = [1, 2, 3, 4, 5]
f = open("file", "rb")
loaded = = pickle.load(f)
f.close()
```
