= RealWorld Elixir 개발 일지

. 저장소: https://github.com/nyeong/realworld-elixir[nyeong/realworld-elixir]

== 목적

나는 웹을 공부하면서 온전한 웹 페이지를 처음부터 끝까지 개발한 경험은 부족하다.
블로그 클론 프로젝트인 RealWorld를 명세에 따라 구현하며 인/허가, CRUD, 웹 보안, 데이터베이스 등
주제를 공부하자.

== 목표

온전한 백엔드 구현:::
  https://realworld-docs.netlify.app/docs/specs/backend-specs/introduction[주어진 백엔드 명세]를 온전히 구현한다.
고심하지 말기:::
  고민은 해봐도 고심은 하지 말자. 여러 선택지가 있을 때 참고할만한 지표가 부족하다면 감으로 고르자.
  개발이 막히는 것보다야 낫다.
벤치마킹:::
  잘 짰는지 평가할 방법이 필요하다. 어느정도 성능이 나오는지 측정할 방법을 찾아보자.
의사결정, 기록 남기기:::
  블로그랑 GitHub Issue 등을 활용하여 남기자.
보안 테스트:::
  <<owasp>>를 참고하여 웹 보안을 달성하자.
추가 기능 한 가지 구현:::
  명세에 정의되어 있지 않는 추가 기능을 하나 구현하자.

== 설치

https://hexdocs.pm/phoenix/installation.html[Phoenix 문서]

사용한 엘릭서는 1.15이고 OTP는 26버전이다. phoenix는 1.7 버전을 이용했다.

[source,bash]
----
$ elixir --version
Erlang/OTP 26 [erts-14.0.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit]

Elixir 1.15.4 (compiled with Erlang/OTP 26)
----

[source,bash]
----
# Hex 패키지 매니저 설치.
$ mix local.hex
# Phoenix 프로젝트 생성
$ mix phx.new real_world
# 의존성 설치, 컴파일, DB 생성
$ cd real_world
$ mix do deps.get, deps.compile, ecto.create, phx.server
----

mix에서 여려 명령을 한 번에 실행하려면 https://hexdocs.pm/mix/1.15/Mix.Tasks.Do.html[do]를
쓰는데, 특이하게 명령을 ``+``나 ``,``로 구분한다. 서브 커맨드도 ``.``으로 네임스페이스가 있어서
뭔가 유닉스 명령어스럽지는 않은 느낌이라 상당히 어색하다.

로컬에 개발환경 만들고 git 연결하자:

[source,bash]
----
$ git remote add https://github.com/nyeong/realworld-elixir.git
$ git push origin main
----

== 데이터베이스 설계

난 데이터베이스에는 영 젬병이다. 컴퓨터 공학을 전공했으나 데이터베이스 관련 강의를 들은 적이 없다.
다만 주워들은 바로는 데이터베이스를 설계하기 위해서는 아래의 과정을 거친다:

.데이터베이스 설계 단계<<sidd>>
. 요구사항 분석
+
사용자가 데이터베이스에게 요구하는 것이 무엇인지 분석한다.
. 개념 설계
+
객체, 객체의 속성, 객체 사이의 관계를 도출하여 ERD를 작성한다.
. 논리 설계
+
ERD를 바탕으로 쓰고자하는 데이터베이스의 논리구조에 적합한 릴레이션 스키마를 설계한다.
이 과정에서 정규화를 적용하여 데이터베이스의 중복을 줄이고, 정합성을 높인다.
. 물리 설계
+
릴레이션 스키마를 바탕으로 특정 데이터베이스 시스템을 감안하여 물리적 스키마를 설계한다.
필요한 구간에 index를 걸거나, 반정규화를 통해 데이터베이스의 읽기 효율을 높인다.
최종적으로 SQL이 생성된다.
. 보안 설계
+
누가 어떤 데이터에 어떻게 접근해야하는지 재검토하고 제한하고 허용한다.

=== 요구사항 분석

순서대로 생각해보자.
프로젝트의 기본적인 요구사항은 RealWorld의
https://www.realworld.how/docs/implementation-creation/features[Features] 문서와
https://www.realworld.how/docs/specs/backend-specs/introduction/[백엔드 스펙] 문서에서
볼 수 있다.

.RealWorld Features
- Authenticate users via JWT (login/signup pages + logout button on settings page)
- CRU- users (sign up & settings page - no deleting required)
- CRUD Articles
- CR-D Comments on articles (no updating required)
- GET and display paginated lists of articles
- Favorite articles
- Follow other users

페이지를 보면 User, Article, Comment와 같은 개체가 필요함을 알 수 있다.
추가로 백엔드 스펙의 Endpoints와 API Response format을 보면 Tag라는 개체도 필요하고,
각 개체 사이의 관계와 개체의 속성도 도출할 수 있다. 개체 사이의 관계를 ↔를 N:M, ↦를 1:N 관계로 표기하면 아래와 같다:

.도출한 개체 사이의 관계
- User ↦ Article (write)
+
유저는 글을 쓸 수 있다. 유저는 여러 글을 쓸 수 있으나, 글에는 단 한 명의 작성자만 있으므로 1:N 관계이다.
- User ↦ Comment (write)
+
유저는 댓글을 쓸 수 있다. 유저는 여러 댓글을 쓸 수 있으나, 댓글에는 단 한 명의 작성자만 있으므로 1:N 관계이다.
- Article ↦ Comment (be commented on)
+
글에는 댓글이 달린다. 어떤 글에 여러 댓글이 달릴 수 있으나, 어떤 댓글은 단 하나의 글에만 달릴 수 있으므로 1:N 관계이다.
- User ↔ User (follow)
+
유저는 유저를 팔로우할 수 있다. 한 유저가 여러 유저를 팔로우 할 수 있고, 여러 유저가 한 유저를 팔로우
할 수 있으므로 N:M 관계이다.
- User ↔ Article (add to favorite)
+
유저는 글을 즐겨찾기에 추가할 수 있다. 유저가 여러 글을 좋아요 할 수 있고, 한 글은 여러 유저가
좋아요 할 수 있으므로 N:M 관계이다.
- Article ↔ Tag (tagged)
+
글에 태그를 달 수 있다. 하나의 글에는 여러 개의 태그가 달릴 수 있고, 어떤 태그는 여러 글에 달릴 수
있으므로 N:M 관계이다.

=== 논리 설계

TODO

=== 데이터베이스 정규화

TODO

=== 물리적 설계

Ecto의 마이그레이션 기능을 이용할 것이므로 SQL을 직접 작성할 필요는 없다. 다만 개념적인 고민을 위해
어떻게 DDL을 작성할지 고민해보자.

글쓰기, 댓글달기와 같은 관계는 1:N 관계이다. RDBMS에서는 아래처럼 외래키를 걸어서 구현할 수 있다.

.1:N 관계 구현
[source, SQL]
----
CREATE TABLE User (
  id INT PRIMARY KEY
);

CREATE TABLE Article (
  id INT PRIMARY KEY,
  author_id INT NOT NULL,
  FOREIGN KEY (author_id) REFERENCES User (id)
);
----

즐겨찾기와 같은 N:M 관계는 조금 다르다. 구현을 위해서 중간 테이블을 만들어야한다.

.N:M 관계 구현
[source, SQL]
----
CREATE TABLE User (
  id INT PRIMARY KEY
);

CREATE TABLE Article (
  id INT PRIMARY KEY
);

CREATE TABLE Favorite (
  user_id INT,
  article_id INT,
  PRIMARY KEY (user_id, article_id),
  FOREIGN KEY (user_id) REFERENCES User (id),
  FOREIGN KEY (article_id) REFERENCES Article (id)
);
----

TODO: 외래키의 제약조건에 대한 설명

각 속성에 대해서도 조금 살펴보자. email, password, username과 같은 다양한 특성의 문자열 속성이
필요하다. PostgreSQL에서는 길이에 따라 세 가지 타입으로 문자열을 나눈다. <<pg83>>

- 다소 길 것으로 예상됨: User.bio, Comment.body, Article.body, ...
- 일반적으로 길이가 정해져 있음: Article.slug, Article.title, User.email, ...
- 길이가 정해져 있음: User.password

대소문자 구별하는 경우도 생각해보자. User.username과 User.email은 대소문자를 어떻게 할 지도 정해야 한다.

[DBML]
----
// Repo: https://github.com/nyeong/realworld-elixir/issues/2
// Docs: https://dbml.dbdiagram.io/docs
// dbdiagram: https://dbdiagram.io/d/RealWorld-650c167b02bd1c4a5e013350

Table User {
  id integer [primary key]
  username varchar [unique]
  email varchar [unique]
  password varchar
  bio varchar
  image varchar
  created_at timestamp
  updated_at timestamp
}

Table Article {
  id integer [primary key]
  title varchar
  description varchar
  body varchar
  author_id integer
  favorites_count integer
  created_at timestamp
  updated_at timestamp
}

Table Comment {
  id integer [primary key]
  body varchar
  author_id integer
  article_id integer
  created_at timestamp
  updated_at timestamp
}

Table Tag {
  id integer [primary key]
  name varchar
  created_at timestamp
  updated_at timestamp
}

// Follow
Table Follow {
  follower integer [ref: > User.id]
  following integer [ref: > User.id]
  created_at timestamp
  updated_at timestamp
}

// Favorite
Table Favorite {
  user integer [ref: > User.id]
  article integer [ref: > Article.id]
  created_at timestamp
  updated_at timestamp
}

// Tag
Table Tagging {
  article integer [ref: > Article.id]
  tag integer [ref: > Tag.id]
  created_at timestamp
  updated_at timestamp
}

// Write
Ref: User.id < Article.author_id
Ref: User.id < Comment.author_id

// Comment
Ref: Article.id < Comment.article_id
----

== User CRU 구현하기

기본적인 데이터베이스 모델링 계획이 끝났으니 이를 기반으로 ORM을 작성할 수 있다. 구현해야하는 기능이
크게 7가지 정도 되는데, 모든 기능이 유저에 의존적이다. 유저 CRU-를 먼저 구현하자. Delete를
구현할 필요가 없다고 하니 Create, Read, Update만 구현하면 된다.

유저 CRU-를 구현하려면 구체적으로 무엇을 해야하는가? Phoenix는 MVC 프레임워크이므로 이대로 나누어서
생각해보자:

. 데이터베이스에 User를 저장할 테이블을 만든다.
. 어플리케이션에서 User를 표현할 모델을 만든다.
. User를 사용자에게 보여줄 뷰를 만든다.
. 뷰와 모델을 다룰 컨트롤러를 만든다.

[mermaid]
----
----

구체적으로 무엇을 만들어야하는지 모듈 단위로 생각하면 아래와 같다:

- ``RealWorld.Accounts.User``에 유저 모델을 정의한다.
- ``RealWorld.Accounts``에 유저 모델을 이용하는 함수들을 정의한다.
- ``RealWorldWeb.UserJSON``에 유저 뷰를 정의한다.
- ``RealWorldWeb.UserController``에 유저 컨트롤러를 정의한다.
- ``RealWorldWeb.Router``에 라우팅 맵을 정의한다.

문서를 보던 중 https://hexdocs.pm/phoenix/mix_phx_gen_auth.html[`phx.gen.auth`]라는 명령어가 있길래 한 번 써봤다.
미리 설계된 인증 시스템을 앱에 추가할 수 있다고 한다.

[source,bash]
----
$ mix phx.gen.auth Accounts User users --hashing-lib argon2
----

아래의 파일들이 수정되거나 추가된다:

----
lib
├── real_world/accouts
│   │          ├── user.ex
│   │          ├── user_notifier.ex
│   │          └── user_token.ex
│   └── accounts.ex
└── real_world_web
    ├── components/layouts/root.html.heex
    ├── controllers/user_session_controller.ex
    ├── live
    │   ├── user_confirmation_instructions_live.ex
    │   ├── user_confirmation_live.ex
    │   ├── user_forgot_password_live.ex
    │   ├── user_login_live.ex
    │   ├── user_registration_live.ex
    │   ├── user_reset_password_live.ex
    │   └── user_settings_live.ex
    ├── router.ex
    └── user_auth.ex
priv
└── repo/migrations
         └── 20230921103152_create_users_auth_tables.exs
----

요약하면 아래의 작업을 해준 셈이다.

. users 마이그레이션을 생성하여 데이터베이스 스키마를 만들 준비를 함.
. users 스키마를 생성하여 Ecto를 이용하여 데이터를 조작할 준비를 함.
. users를 검증하는 기본적인 changeset을 생성함.
. users를 생성할 때 비밀번호를 Argon2 알고리즘으로 암호화하고, 로그인할 때 이를 검증함.
. 회원가입 시 이메일로 검증 토큰을 보내는 로직을 생성함.
. Accounts 모듈을 생성하여 User와 관련된 동작을 노출함.
. 위 기능에 대한 controller와 liveview를 생성함.
. 세션에서 유저 토큰을 가져와 conn에 유저 정보를 삽입하는 미들웨어를 생성하고 이를 파이프라인에 끼워넣음
. 등등...

아래 명령어로 추가된 의존성을 가져오고, 컴파일하고, DB에 변경사항을 기록한 후에 서버를 실행해본다.

[source, bash]
----
$ mix do deps.get, deps.compile, ecto.migrate
$ mix phx.server
----

. Accounts: User, UserToken, UserNotifier 등의 모듈을 담을 모듈.

+
Web에서는 `Accounts` 모듈만 가져다 쓰면 되도록 꼭 필요한 정보만 노출하는 역할을 한다.

. User: User 스키마를 정의할 모듈.
. users: 테이블 이름.

``priv/repo/migrations``에 마이그레이션이 생성된다. ``Ecto.Migration``을 이용하여 정의.

[source, elixir]
----
create table(:users) do
  add :email, :citext, null: false
  add :hashed_password, :string, null: false
  add :confirmed_at, :naive_datetime
  timestamps()
end
----

`citext` 필드는 대소문자를 구별하지 않는(case-insensitive) 타입이다.
지원하지 않는 DB도 있다고 하는데, PostgreSQL에서는 다행히 지원한다.
지원하지 않는 경우, 저장하기 전에 모두 소문자로 바꾸는 편이 좋다.

많은 작업을 공짜로 해준 것은 좋지만 이메일 인증이나 이에 대한 LiveView는 지금
하려는 작업이 아니고, 직접 만들고 싶어서 작업 내용을 날렸다.

[source, bash]
----
# 마이그레이션 취소하기
$ mix ecto.rollback
# 커밋하지 않은 변경사항 초기화하기
$ git checkout .
# git으로 추적되지 않는 파일 날리기
$ git clean -fd
$ git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
----

대신 ``phx.gen.json``을 이용하여 json view를 생성하고 가장 기본적인 CRUD에 대한
도움만 받자. 이것도 동일하게 Context 이름, 모듈 이름, 테이블 이름, 필드명:필드타입 순으로 인자를 받는다.

[source, bash]
----
$ mix phx.gen.json Accounts User users username:string email:string bio:text image:string hashed_password:string
* creating lib/real_world_web/controllers/user_controller.ex
* creating lib/real_world_web/controllers/user_json.ex
* creating lib/real_world_web/controllers/changeset_json.ex
* creating test/real_world_web/controllers/user_controller_test.exs
* creating lib/real_world_web/controllers/fallback_controller.ex
* creating lib/real_world/accounts/user.ex
* creating priv/repo/migrations/20230921111351_create_users.exs
* creating lib/real_world/accounts.ex
* injecting lib/real_world/accounts.ex
* creating test/real_world/accounts_test.exs
* injecting test/real_world/accounts_test.exs
* creating test/support/fixtures/accounts_fixtures.ex
* injecting test/support/fixtures/accounts_fixtures.ex

Add the resource to your :api scope in lib/real_world_web/router.ex:

    resources "/users", UserController, except: [:new, :edit]


Remember to update your repository by running migrations:

    $ mix ecto.migrate
----

모델, 뷰, 컨트롤러, 테스트, 마이그레이션 등에 대한 보일러 플레이트를 생성해준다.

`ecto.migrate` 돌리기 전에, 마이그레이션을 조금만 손보자.

[source,elixir]
----
defmodule RealWorld.Repo.Migrations.CreateUsers do
  use Ecto.Migration

  def change do
    create table(:users) do
      add :username, :citext, null: false <1>
      add :email, :citext, null: false
      add :bio, :text <2>
      add :image, :string
      add :hashed_password, :string

      timestamps()
    end

    create unique_index(:users, [:username]) <3>
    create unique_index(:users, [:email])
  end
end
----
<1> ``string``에서 ``citext``로 변경하였다.
<2> ``bio``는 `string` 대신 ``text``로 선언하였다.
<3> ``username``과 ``email``에 각각 유니크 인덱스를 걸어주었다. `[:username, :email]` 형태로 한 번에
걸 경우 복합 인덱스가 되어버려 동작이 달라지므로 유의하자.

DB에 접속하여 제대로 반영되었는지 확인해보자. 특별히 바꾸지 않았다면 데이터베이스 이름은 `app_name_dev`,
username은 ``postgres``이다. `config` 디렉토리 안에 정의되어있다.

[source]
----
$ psql real_world_dev -U postgres
psql (16.0 (Homebrew))
Type "help" for help.

real_world_dev=# SELECT * FROM information_schema.tables
WHERE table_schema NOT LIKE 'pg_%' AND TABLE_SCHEMA != 'information_schema';
... 생략 ...

real_world_dev=# \dt
List of relations
-[ RECORD 1 ]-------------
Schema | public
Name   | schema_migrations
Type   | table
Owner  | postgres
-[ RECORD 2 ]-------------
Schema | public
Name   | users
Type   | table
Owner  | postgres

real_world_dev=# \d+ public.users
... 생략 ...
----

PostgreSQL은 내부 데이터를 `information_schema` 안에 저장하므로, 이를 쿼리해서도 정보를 얻을 수
있고, ``\dt``와 같은 메타 커맨드를 이용해서도 알 수 있다. <<psql>> ``\d+``를 이용하면
해당 테이블의 컬럼 이름, 타입, 인덱스 등 자세한 정보를 알 수 있다. 확인해보니 ``:string``으로 선언한
필드는 모두 ``character varying(255)``로 정의된 것을 볼 수 있다.

데이터베이스에 테이블이 잘 정의되었으므로 모델 정의를 보자. 모델 정의는 크게 스키마와 changeset으로
나뉘어있다. 스키마는 외부 데이터를 Elixir의 자료구조로 표현하는 역할을, 이를 검증하고 제약하는 역할을
담당한다.

[source, elixir]
----
defmodule RealWorld.Accounts.User do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :image, :string
    field :username, :string
    field :email, :string
    field :bio, :string
    field :hashed_password, :string

    timestamps()
  end

  @doc false
  def changeset(user, attrs) do
    user
    |> cast(attrs, [:username, :email, :bio, :image, :hashed_password])
    |> validate_required([:username, :email, :bio, :image, :hashed_password])
  end
end
----

[source,elixir]
----
def create(conn, %{"user" => user_params}) do
  with {:ok, %User{} = user} <- Accounts.create_user(user_params) do
    conn
    |> put_status(:created) <1>
    |> put_resp_header("location", ~p"/api/users/#{user}") <2>
    |> render(:show, user: user) <3>
  end
end
----
<1> 일반적인 성공의 status code는 200이지만, 무언가 잘 만들어 졌을 때에는 201 Created. <<201c>>
<2> 이때 헤더에 ``location``을 추가하여 만들어진 리소스의 URL을 알려줌.
<3> view를 이용하여 렌더하기. 첫번째 인자가 template. UserJSON의 동명의 함수가 호출됨.

[bibliography]
== 참고

- https://realworld-docs.netlify.app/[RealWorld]
- https://github.com/gothinkster/realworld[gothinkster/realworld]
- [[[sidd]]] Prof. Joe Hellerstein, https://www.youtube.com/watch?v=LWYU_G6tivQ&list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&index=157[Lecture 16 Part 2 Overview of DB Design]. UC Berkeley CS186 "Introduction to Database Systems".
- [[[owasp]]] https://cheatsheetseries.owasp.org/index.html[OWASP Cheat Sheet Series]
- [[[pg83]]] https://www.postgresql.org/docs/16/datatype-character.html[PostgreSQL 16 - 8.3. Character Types]
- [[[psql]]] https://www.postgresql.org/docs/16/app-psql.html[psql - PostgreSQL Client Applications]
- [[[201c]]] https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201
