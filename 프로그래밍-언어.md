# 프로그래밍 언어

## 복사의 모호함

참조 투명성

```ruby
array = [1, 2, 3]

do_something_with(array)
array.do_something

do_something_other_with(array) # 이때 array는 내가 생각한 array인가?
```

### 복사만 한다

elixir

### 빌릴 때 별도로 표기한다

rust

```rust
// 애초에 `mut`이 아니면 바뀔 수도 없다.
let mut array = vec![1, 2, 3];

// 빌리고 값을 바꾸려면 `&mut`로 명시해야한다.
do_something_with_mod(&mut array);

// `&`로 빌려준 것은 값이 바뀌지 않으니 안심이다.
do_something_with_not_mod(&array);
```

## 가변성을 어떻게 다룰 것인가

> GOTO was evil because we asked, "how did I get to this point of execution?" Mutability leaves us with, "how did I get to this state?" -- Jessica Joy Kerr

### 변할 수 없게 한다

```elixir
immutable_object = %object{ value: :something }
```

### 변할 수 있는 것들을 따로 명시한다.

```rust
// `mut` 선언이 없으면 절대 불변이다.
let immutable_object = SomeObject::new();

// `mut` 선언을 해야 그 값을 바꿀 수 있다.
let mut mutable_object = SomeObject::new();
```

## 값이 없음을 어떻게 표현할 것인가

### NULL

### Maybe<T>

```rust
let maybe_fail = 
```

## 에러를 어떻게 표현하고 전파할 것인가

### 패턴 매칭

```go
func Open(name string) (*File, error)

f, err := os.Open("C:\\temp\\1.txt")
if err != nil {
  log.Fatal(err.Error())
}
// do something with f
```

```elixir
open(Path) :: {:ok, res} | {:error, posix()}

case File.open("foo.tar.gz") do
  {:ok, file} ->
    # do something with file
  {:error, error} ->
    Logger.error("Error: #{error}")
end
```

### Result<T>

## 동시성을 어떻게 해결할 것인가

### 아주 작은 스레드

### 비동기 콜백

## 코드를 어떻게 잘게 쪼갤 것인가

### 모듈

## 무엇이 참이고 무엇이 거짓인가?

### 참과 거짓 외에는 그 무엇도 의미가 없다

```rust
if 0 {
  // do something
}
```

```
Output of rustc 1.59.0 (Compiler #1)
error[E0308]: mismatched types
 --> <source>:2:8
   |
   2 |     if 0 {
     |        ^ expected `bool`, found integer

     error: aborting due to previous error

     For more information about this error, try `rustc --explain E0308`.
     Compiler returned: 1
```

### 거짓만이 거짓이다

```ruby

``` if a

### 공허는 거짓과 같다

```c
if (0) {
  // do something
}
```

```python
a = []
if a:
  a.append("hi")
```
